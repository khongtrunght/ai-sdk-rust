use super::tool_result_output::ToolResultOutput;
use crate::SharedProviderMetadata;
use serde::{Deserialize, Serialize};

/// Content generated by the language model
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "kebab-case")]
pub enum Content {
    /// Text content part
    Text(TextPart),
    /// Reasoning content part (for reasoning models like o1)
    Reasoning(ReasoningPart),
    /// File content part (images, audio, etc.)
    File(FilePart),
    /// Source citation content part
    Source(SourcePart),
    /// Tool call content part
    ToolCall(ToolCallPart),
    /// Tool result content part
    ToolResult(ToolResultPart),
}

/// Text content
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TextPart {
    /// The text content
    pub text: String,

    /// Provider-specific metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// Reasoning content (for reasoning models like o1)
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReasoningPart {
    /// The reasoning text
    pub reasoning: String,

    /// Provider-specific metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// File content
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FilePart {
    /// File data (binary or URL)
    pub data: super::FileData,

    /// MIME type (e.g., "image/jpeg")
    pub media_type: String,

    /// Provider-specific metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// Source citation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SourcePart {
    /// The type of source
    pub source_type: SourceType,
    /// Unique identifier for the source
    pub id: String,

    /// URL of the source
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,

    /// Title of the source
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    /// Provider-specific metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// Type of source citation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SourceType {
    /// URL-based source
    Url,
    /// Document-based source
    Document,
}

/// Tool call from the model
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ToolCallPart {
    /// Unique identifier for the tool call
    pub tool_call_id: String,
    /// Name of the tool being called
    pub tool_name: String,
    /// Stringified JSON with tool arguments
    pub input: String,

    /// Whether the tool was executed by the provider
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_executed: Option<bool>,

    /// Whether the tool call is dynamic
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dynamic: Option<bool>,

    /// Provider-specific metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// Tool execution result
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ToolResultPart {
    /// Identifier of the tool call this result is for
    pub tool_call_id: String,
    /// Name of the tool that generated this result
    pub tool_name: String,
    /// Structured output from the tool execution
    pub output: ToolResultOutput,

    /// Whether the result is preliminary
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preliminary: Option<bool>,

    /// Provider-specific metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_content_text_serialization() {
        let content = Content::Text(TextPart {
            text: "Hello".into(),
            provider_metadata: None,
        });
        let json = serde_json::to_value(&content).unwrap();
        assert_eq!(json["type"], "text");
        assert_eq!(json["text"], "Hello");
    }

    #[test]
    fn test_content_tool_call() {
        let content = Content::ToolCall(ToolCallPart {
            tool_call_id: "call-123".into(),
            tool_name: "search".into(),
            input: r#"{"query":"test"}"#.into(),
            provider_executed: None,
            dynamic: None,
            provider_metadata: None,
        });
        let json = serde_json::to_value(&content).unwrap();
        assert_eq!(json["type"], "tool-call");
        assert_eq!(json["toolCallId"], "call-123");
        assert_eq!(json["toolName"], "search");
    }

    #[test]
    fn test_content_reasoning() {
        let content = Content::Reasoning(ReasoningPart {
            reasoning: "Let me think...".into(),
            provider_metadata: None,
        });
        let json = serde_json::to_value(&content).unwrap();
        assert_eq!(json["type"], "reasoning");
        assert_eq!(json["reasoning"], "Let me think...");
    }

    #[test]
    fn test_source_type_serialization() {
        let source = SourcePart {
            source_type: SourceType::Url,
            id: "src-1".into(),
            url: Some("https://example.com".into()),
            title: None,
            provider_metadata: None,
        };
        let json = serde_json::to_value(&source).unwrap();
        assert_eq!(json["sourceType"], "url");
    }

    #[test]
    fn test_tool_result_text_output() {
        let result = ToolResultPart {
            tool_call_id: "call-123".into(),
            tool_name: "test_tool".into(),
            output: ToolResultOutput::Text {
                value: "success".into(),
                provider_metadata: None,
            },
            preliminary: None,
            provider_metadata: None,
        };
        let json = serde_json::to_value(&result).unwrap();
        assert_eq!(json["toolName"], "test_tool");
        assert_eq!(json["output"]["type"], "text");
        assert_eq!(json["output"]["value"], "success");
    }

    #[test]
    fn test_tool_result_error_output() {
        let result = ToolResultPart {
            tool_call_id: "call-123".into(),
            tool_name: "test_tool".into(),
            output: ToolResultOutput::ErrorText {
                value: "error occurred".into(),
                provider_metadata: None,
            },
            preliminary: None,
            provider_metadata: None,
        };
        let json = serde_json::to_value(&result).unwrap();
        assert_eq!(json["output"]["type"], "error-text");
        assert_eq!(json["output"]["value"], "error occurred");
        assert_eq!(json["toolName"], "test_tool");
    }
}
