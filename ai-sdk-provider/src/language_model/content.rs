use crate::{JsonValue, SharedProviderMetadata};
use serde::{Deserialize, Serialize};

/// Content generated by the language model
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "kebab-case")]
pub enum Content {
    Text(TextPart),
    Reasoning(ReasoningPart),
    File(FilePart),
    Source(SourcePart),
    ToolCall(ToolCallPart),
    ToolResult(ToolResultPart),
}

/// Text content
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TextPart {
    /// The text content
    pub text: String,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// Reasoning content (for reasoning models like o1)
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReasoningPart {
    /// The reasoning text
    pub reasoning: String,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// File content
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FilePart {
    /// File data (binary, base64, or URL)
    pub data: Vec<u8>,

    /// MIME type (e.g., "image/jpeg")
    pub media_type: String,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// Source citation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SourcePart {
    pub source_type: SourceType,
    pub id: String,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SourceType {
    Url,
    Document,
}

/// Tool call from the model
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ToolCallPart {
    pub tool_call_id: String,
    pub tool_name: String,
    /// Stringified JSON with tool arguments
    pub input: String,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_executed: Option<bool>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub dynamic: Option<bool>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// Tool execution result
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ToolResultPart {
    pub tool_call_id: String,
    pub result: JsonValue,

    #[serde(default, skip_serializing_if = "is_false")]
    pub is_error: bool,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub preliminary: Option<bool>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

fn is_false(v: &bool) -> bool {
    !v
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_content_text_serialization() {
        let content = Content::Text(TextPart {
            text: "Hello".into(),
            provider_metadata: None,
        });
        let json = serde_json::to_value(&content).unwrap();
        assert_eq!(json["type"], "text");
        assert_eq!(json["text"], "Hello");
    }

    #[test]
    fn test_content_tool_call() {
        let content = Content::ToolCall(ToolCallPart {
            tool_call_id: "call-123".into(),
            tool_name: "search".into(),
            input: r#"{"query":"test"}"#.into(),
            provider_executed: None,
            dynamic: None,
            provider_metadata: None,
        });
        let json = serde_json::to_value(&content).unwrap();
        assert_eq!(json["type"], "tool-call");
        assert_eq!(json["toolCallId"], "call-123");
        assert_eq!(json["toolName"], "search");
    }

    #[test]
    fn test_content_reasoning() {
        let content = Content::Reasoning(ReasoningPart {
            reasoning: "Let me think...".into(),
            provider_metadata: None,
        });
        let json = serde_json::to_value(&content).unwrap();
        assert_eq!(json["type"], "reasoning");
        assert_eq!(json["reasoning"], "Let me think...");
    }

    #[test]
    fn test_source_type_serialization() {
        let source = SourcePart {
            source_type: SourceType::Url,
            id: "src-1".into(),
            url: Some("https://example.com".into()),
            title: None,
            provider_metadata: None,
        };
        let json = serde_json::to_value(&source).unwrap();
        assert_eq!(json["sourceType"], "url");
    }

    #[test]
    fn test_tool_result_is_error_default() {
        let result = ToolResultPart {
            tool_call_id: "call-123".into(),
            result: JsonValue::String("success".into()),
            is_error: false,
            preliminary: None,
            provider_metadata: None,
        };
        let json = serde_json::to_value(&result).unwrap();
        // is_error should not be serialized when false
        assert!(json.get("isError").is_none());
    }

    #[test]
    fn test_tool_result_is_error_true() {
        let result = ToolResultPart {
            tool_call_id: "call-123".into(),
            result: JsonValue::String("error".into()),
            is_error: true,
            preliminary: None,
            provider_metadata: None,
        };
        let json = serde_json::to_value(&result).unwrap();
        assert_eq!(json["isError"], true);
    }
}
