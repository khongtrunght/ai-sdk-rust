use crate::{JsonValue, SharedProviderMetadata};
use serde::{Deserialize, Serialize};

/// Content generated by the language model
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "kebab-case")]
pub enum Content {
    /// Text content part
    Text(TextPart),
    /// Reasoning content part (for reasoning models like o1)
    Reasoning(ReasoningPart),
    /// File content part (images, audio, etc.)
    File(FilePart),
    /// Source citation content part
    Source(SourcePart),
    /// Tool call content part
    ToolCall(ToolCallPart),
    /// Tool result content part
    ToolResult(ToolResultPart),
}

/// Text content
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TextPart {
    /// The text content
    pub text: String,

    /// Provider-specific metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// Reasoning content (for reasoning models like o1)
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReasoningPart {
    /// The reasoning text
    pub reasoning: String,

    /// Provider-specific metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// File content
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FilePart {
    /// File data (binary or URL)
    pub data: super::FileData,

    /// MIME type (e.g., "image/jpeg")
    pub media_type: String,

    /// Provider-specific metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// Source citation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SourcePart {
    /// The type of source
    pub source_type: SourceType,
    /// Unique identifier for the source
    pub id: String,

    /// URL of the source
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,

    /// Title of the source
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    /// Provider-specific metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// Type of source citation
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SourceType {
    /// URL-based source
    Url,
    /// Document-based source
    Document,
}

/// Tool call from the model
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ToolCallPart {
    /// Unique identifier for the tool call
    pub tool_call_id: String,
    /// Name of the tool being called
    pub tool_name: String,
    /// Stringified JSON with tool arguments
    pub input: String,

    /// Whether the tool was executed by the provider
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_executed: Option<bool>,

    /// Whether the tool call is dynamic
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dynamic: Option<bool>,

    /// Provider-specific metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

/// Tool execution result
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ToolResultPart {
    /// Identifier of the tool call this result is for
    pub tool_call_id: String,
    /// Result data from the tool execution
    pub result: JsonValue,

    /// Whether the result represents an error
    #[serde(default, skip_serializing_if = "is_false")]
    pub is_error: bool,

    /// Whether the result is preliminary
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preliminary: Option<bool>,

    /// Provider-specific metadata
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider_metadata: Option<SharedProviderMetadata>,
}

fn is_false(v: &bool) -> bool {
    !v
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_content_text_serialization() {
        let content = Content::Text(TextPart {
            text: "Hello".into(),
            provider_metadata: None,
        });
        let json = serde_json::to_value(&content).unwrap();
        assert_eq!(json["type"], "text");
        assert_eq!(json["text"], "Hello");
    }

    #[test]
    fn test_content_tool_call() {
        let content = Content::ToolCall(ToolCallPart {
            tool_call_id: "call-123".into(),
            tool_name: "search".into(),
            input: r#"{"query":"test"}"#.into(),
            provider_executed: None,
            dynamic: None,
            provider_metadata: None,
        });
        let json = serde_json::to_value(&content).unwrap();
        assert_eq!(json["type"], "tool-call");
        assert_eq!(json["toolCallId"], "call-123");
        assert_eq!(json["toolName"], "search");
    }

    #[test]
    fn test_content_reasoning() {
        let content = Content::Reasoning(ReasoningPart {
            reasoning: "Let me think...".into(),
            provider_metadata: None,
        });
        let json = serde_json::to_value(&content).unwrap();
        assert_eq!(json["type"], "reasoning");
        assert_eq!(json["reasoning"], "Let me think...");
    }

    #[test]
    fn test_source_type_serialization() {
        let source = SourcePart {
            source_type: SourceType::Url,
            id: "src-1".into(),
            url: Some("https://example.com".into()),
            title: None,
            provider_metadata: None,
        };
        let json = serde_json::to_value(&source).unwrap();
        assert_eq!(json["sourceType"], "url");
    }

    #[test]
    fn test_tool_result_is_error_default() {
        let result = ToolResultPart {
            tool_call_id: "call-123".into(),
            result: JsonValue::String("success".into()),
            is_error: false,
            preliminary: None,
            provider_metadata: None,
        };
        let json = serde_json::to_value(&result).unwrap();
        // is_error should not be serialized when false
        assert!(json.get("isError").is_none());
    }

    #[test]
    fn test_tool_result_is_error_true() {
        let result = ToolResultPart {
            tool_call_id: "call-123".into(),
            result: JsonValue::String("error".into()),
            is_error: true,
            preliminary: None,
            provider_metadata: None,
        };
        let json = serde_json::to_value(&result).unwrap();
        assert_eq!(json["isError"], true);
    }
}
